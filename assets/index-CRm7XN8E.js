(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const t of document.querySelectorAll('link[rel="modulepreload"]'))a(t);new MutationObserver(t=>{for(const o of t)if(o.type==="childList")for(const l of o.addedNodes)l.tagName==="LINK"&&l.rel==="modulepreload"&&a(l)}).observe(document,{childList:!0,subtree:!0});function n(t){const o={};return t.integrity&&(o.integrity=t.integrity),t.referrerPolicy&&(o.referrerPolicy=t.referrerPolicy),t.crossOrigin==="use-credentials"?o.credentials="include":t.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function a(t){if(t.ep)return;t.ep=!0;const o=n(t);fetch(t.href,o)}})();const C=.08,U=2,Z=.25,j=6,J=75,Q=150,k=150,ee=500,re=10,te=30,oe=250,S=32,ne=`#version 300 es
precision mediump float;

in vec2 vertexPos;
in vec3 vertexColor;
out vec3 fragmentColor;

uniform vec2 canvasSize;
uniform vec2 shapeLoc;
uniform float shapeSize;

void main() {
    fragmentColor = vertexColor;
    vec2 finalVertexPos = vertexPos * shapeSize + shapeLoc;
    vec2 clipPos = finalVertexPos * 2.0 / canvasSize - 1.0;

    gl_Position = vec4(clipPos, 0.0, 1.0);
}`,ae=`#version 300 es
precision mediump float;

in vec3 fragmentColor;
out vec4 oColor;

void main() {
    oColor = vec4(fragmentColor, 1.0);
}`;function ie(){const r=[];for(let e=0;e<S;e++){const n=e*Math.PI*2/S,a=(e+1)*Math.PI*2/S,t=Math.cos(n),o=Math.sin(n),l=Math.cos(a),v=Math.sin(a);r.push(0,0,.678,.851,.957),r.push(t,o,.251,.353,.856),r.push(l,v,.251,.353,.856)}return new Float32Array(r)}const ce=new Float32Array([0,1,-1,-1,1,-1]),se=new Float32Array([-1,1,-1,-1,1,-1,-1,1,1,-1,1,1]),fe=new Uint8Array([255,0,0,0,255,0,0,0,255]),le=new Uint8Array([3,236,252,3,90,252,3,107,200]),ue=new Uint8Array([235,64,52,140,3,3,140,3,3,235,64,52,140,3,3,235,64,52]),he=new Uint8Array([115,115,115,45,45,45,45,45,45,115,115,115,45,45,45,115,115,115]);function h(r,e){const n=r.createBuffer();if(!n)throw new Error("Couldn't allocate buffer");return r.bindBuffer(r.ARRAY_BUFFER,n),r.bufferData(r.ARRAY_BUFFER,e,r.STATIC_DRAW),r.bindBuffer(r.ARRAY_BUFFER,null),n}function w(r,e,n,a,t){const o=r.createVertexArray();if(!o)throw new Error("Failed to allocate VAO for two buffers");return r.bindVertexArray(o),r.enableVertexAttribArray(a),r.enableVertexAttribArray(t),r.bindBuffer(r.ARRAY_BUFFER,e),r.vertexAttribPointer(a,2,r.FLOAT,!1,0,0),r.bindBuffer(r.ARRAY_BUFFER,n),r.vertexAttribPointer(t,3,r.UNSIGNED_BYTE,!0,0,0),r.bindBuffer(r.ARRAY_BUFFER,null),r.bindVertexArray(null),o}function de(r,e,n,a){const t=r.createVertexArray();if(!t)throw new Error("Failed to allocate VAO for two buffers");return r.bindVertexArray(t),r.enableVertexAttribArray(n),r.enableVertexAttribArray(a),r.bindBuffer(r.ARRAY_BUFFER,e),r.vertexAttribPointer(n,2,r.FLOAT,!1,5*Float32Array.BYTES_PER_ELEMENT,0),r.vertexAttribPointer(a,3,r.FLOAT,!1,5*Float32Array.BYTES_PER_ELEMENT,2*Float32Array.BYTES_PER_ELEMENT),r.bindBuffer(r.ARRAY_BUFFER,null),r.bindVertexArray(null),t}function f(r,e){return Math.random()*(e-r)+r}class me{constructor(e,n,a,t,o,l,v){this.position=e,this.velocity=n,this.force=a,this.size=t,this.timeRemain=o,this.vao=l,this.numVertices=v}isAlive(){return this.timeRemain>0}update(e){this.velocity[0]+=this.force[0]*e,this.velocity[1]+=this.force[0]*e,this.position[0]+=this.velocity[0]*e,this.position[1]+=this.velocity[1]*e,this.timeRemain-=e}}function Ee(){const r=document.getElementById("demo-canvas");if(!r||!(r instanceof HTMLCanvasElement))throw new Error("Canvas couldn't be accesed.");const e=r.getContext("webgl2");if(!e)throw new Error("This browser doesn't support WebGL 2.");const n=h(e,ce);if(!n)throw new Error("Failed to create triangle vertex position buffer");const a=h(e,fe);if(!a)throw new Error("Failed to create triangle vertex rgb color buffer");const t=h(e,le);if(!t)throw new Error("Failed to create triangle vertex blue color buffer");const o=h(e,se);if(!n)throw new Error("Failed to create square vertex position buffer");const l=h(e,ue);if(!a)throw new Error("Failed to create square vertex red color buffer");const v=h(e,he);if(!t)throw new Error("Failed to create square vertex gray color buffer");const y=h(e,ie());if(!y)throw new Error("Failed to create circle vertex buffer");const d=e.createShader(e.VERTEX_SHADER);if(d===null)throw new Error("Memory for vertex shader couldn't be allocated");if(e.shaderSource(d,ne),e.compileShader(d),!e.getShaderParameter(d,e.COMPILE_STATUS)){const u=e.getShaderInfoLog(d);throw new Error(`${u}`)}const m=e.createShader(e.FRAGMENT_SHADER);if(m===null)throw new Error("Memory for fragment shader couldn't be allocated");if(e.shaderSource(m,ae),e.compileShader(m),!e.getShaderParameter(m,e.COMPILE_STATUS)){const u=e.getShaderInfoLog(m);throw new Error(`${u}`)}const c=e.createProgram();if(c===null)throw new Error("Memory for shader program couldn't be allocated");if(e.attachShader(c,d),e.attachShader(c,m),e.linkProgram(c),!e.getProgramParameter(c,e.LINK_STATUS)){const u=e.getProgramInfoLog(c);throw new Error(`${u}`)}const E=e.getAttribLocation(c,"vertexPos"),A=e.getAttribLocation(c,"vertexColor");if(E<0)throw new Error("Failed to get attribute location vertexPos");if(A<0)throw new Error("Failed to get attribute location vertexColor");const x=e.getUniformLocation(c,"shapeSize");if(x===null)throw new Error("Failed to get shapeSize uniform location");const F=e.getUniformLocation(c,"shapeLoc");if(F===null)throw new Error("Failed to get shapePos uniform location");const _=e.getUniformLocation(c,"canvasSize");if(_===null)throw new Error("Failed to get canvasSize uniform location");const N=w(e,n,a,E,A),O=w(e,n,t,E,A),H=w(e,o,l,E,A),q=w(e,o,v,E,A),D=de(e,y,E,A),R=[{vao:N,numVertices:3},{vao:O,numVertices:3},{vao:H,numVertices:6},{vao:q,numVertices:6},{vao:D,numVertices:S*3}];let s=[],p=C,g=[f(r.width*.1,r.width*.9),f(r.height*.1,r.height*.9)],b=U,T=performance.now();const M=function(){const u=performance.now(),P=(u-T)/1e3;for(T=u,b-=P;b<0;)b=U,g=[f(r.width*.1,r.width*.9),f(r.height*.1,r.height*.9)];for(p-=P;p<0;){p+=C;const i=f(0,2*Math.PI),L=f(J,Q),B=f(0,2*Math.PI),V=f(k,ee),z=[g[0],g[1]],Y=[Math.sin(i)*L,Math.cos(i)*L],G=[Math.sin(B)*V,Math.cos(B)*V],X=f(re,te),W=f(Z,j),$=Math.floor(f(0,R.length)),I=R[$],K=new me(z,Y,G,X,W,I.vao,I.numVertices);s.push(K)}for(let i=0;i<s.length;i++)s[i].update(P);s=s.filter(i=>i.isAlive()).slice(0,oe),r.width=r.clientWidth,r.height=r.clientHeight,e.clearColor(.1,.1,.1,1),e.clear(e.COLOR_BUFFER_BIT|e.DEPTH_BUFFER_BIT),e.viewport(0,0,r.width,r.height),e.useProgram(c),e.uniform2f(_,r.width,r.height);for(let i=0;i<s.length;i++)e.uniform1f(x,s[i].size),e.uniform2f(F,s[i].position[0],s[i].position[1]),e.bindVertexArray(s[i].vao),e.drawArrays(e.TRIANGLES,0,s[i].numVertices);requestAnimationFrame(M)};requestAnimationFrame(M)}try{Ee()}catch(r){console.log("Exception: "+r)}
